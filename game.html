<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EC2 Flashcard Memory — Unlimited Levels</title>
<style>
  :root{
    --bg:#041122; --card:#0f2b49; --accent:#ff9900; --muted:#9fb0d4;
    --good:#15b36a; --bad:#ff4d4d;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:flex; flex-direction:column; align-items:center;
    background:linear-gradient(180deg,#021022,#071a33); color:#fff; font-family: Inter, "Segoe UI", Roboto, Arial;
    padding:18px;
  }
  header{ text-align:center; margin-bottom:12px; }
  h1{ margin:6px 0; color:var(--accent); text-shadow:0 6px 20px rgba(255,153,0,0.06) }
  .sub{ color:var(--muted); margin-top:0; font-size:0.95rem }

  .hud{
    width:100%; max-width:1100px; display:flex; gap:10px; justify-content:space-between; align-items:center;
    margin:10px 0 18px; flex-wrap:wrap;
  }
  .tile{ background:rgba(255,255,255,0.03); padding:10px 14px; border-radius:10px; min-width:110px; text-align:center; }
  .tile strong{ display:block; font-size:1.15rem; color:#fff }
  .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  .main {
    width:100%; max-width:900px; display:flex; gap:18px; align-items:flex-start; justify-content:center;
    flex-wrap:wrap;
  }

  .panel {
    background:linear-gradient(180deg,#071e3a,#08273a);
    border-radius:12px; padding:18px; width:100%; max-width:640px; box-shadow:0 14px 36px rgba(2,8,20,0.6);
  }

  #flashcard {
    background:var(--card); border-radius:10px; padding:22px; min-height:120px; display:flex; align-items:center;
    justify-content:center; text-align:center; font-size:1.15rem; color:#fff; border:2px solid rgba(255,153,0,0.06);
  }

  #flashcard.hidden { opacity:0.06; filter: blur(2px); transition:opacity 0.25s ease; }
  .meta { margin-top:10px; color:var(--muted); font-size:0.9rem }

  .options { margin-top:14px; display:grid; gap:10px; }
  .option-btn {
    background:linear-gradient(180deg,#123b63,#0f3457); border:none; color:#fff; padding:12px 14px; border-radius:10px; cursor:pointer;
    text-align:left; font-weight:600; box-shadow:0 8px 18px rgba(2,8,20,0.6);
  }
  .option-btn:hover { transform:translateY(-2px); }
  .option-btn.correct { outline:3px solid rgba(21,179,106,0.12); box-shadow:0 0 0 3px rgba(21,179,106,0.06) inset; }
  .option-btn.wrong { outline:3px solid rgba(255,77,77,0.12); box-shadow:0 0 0 3px rgba(255,77,77,0.04) inset; }

  .right { color:var(--good) }
  .wrong { color:var(--bad) }

  .sidebar {
    width:280px; min-width:240px; padding:16px; border-radius:12px; background:linear-gradient(180deg,#061f32,#062435);
  }
  .small { font-size:0.9rem; color:var(--muted) }
  .stat-row { display:flex; justify-content:space-between; padding:8px 0; align-items:center; border-bottom:1px dashed rgba(255,255,255,0.02) }
  .big { font-size:1.3rem; font-weight:700; color:#fff }

  .btn {
    background:var(--accent); color:#000; border:none; padding:10px 12px; border-radius:9px; cursor:pointer; font-weight:700;
  }
  .btn.secondary { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.05) }

  footer{ margin-top:18px; color:var(--muted); font-size:0.9rem }
</style>
</head>
<body>

<header>
  <h1>EC2 Flashcard Memory — Endless Levels</h1>
  <p class="sub">Flashcard shows first → hides → choose the correct match. Level auto-increases with correct answers (Normal final speed).</p>
</header>

<div class="hud">
  <div class="tile"><small>Level</small><strong id="level">1</strong><div class="small">difficulty rises automatically</div></div>
  <div class="tile"><small>Score</small><strong id="score">0</strong><div class="small">+10 × level per correct</div></div>
  <div class="tile"><small>Streak</small><strong id="streak">0</strong><div class="small">consecutive correct</div></div>
  <div class="controls">
    <button id="startBtn" class="btn">Start</button>
    <button id="pauseBtn" class="btn secondary">Pause</button>
    <button id="resetBtn" class="btn secondary">Reset</button>
  </div>
</div>

<div class="main">
  <div class="panel">
    <div id="flashcard" class="">Press Start</div>
    <div class="meta" id="meta">Flashcard time: <strong id="flashTimeLabel">4.00s</strong> • Options: <strong id="optionsLabel">3</strong></div>

    <div class="options" id="options"></div>

    <div style="display:flex;gap:8px;margin-top:12px;align-items:center;">
      <button id="skipBtn" class="btn secondary">Skip (−2 score)</button>
      <div style="flex:1"></div>
      <div class="small">Questions answered: <strong id="qcount">0</strong></div>
    </div>
  </div>

  <aside class="sidebar" aria-hidden="false">
    <div class="stat-row"><div class="small">Flashcard side</div><div id="sideLabel" class="big">Term</div></div>
    <div class="stat-row"><div class="small">Flashcard time</div><div id="timeLabel" class="big">4.00s</div></div>
    <div class="stat-row"><div class="small">Options</div><div id="optsLabel" class="big">3</div></div>
    <div class="stat-row"><div class="small">Total pairs in queue</div><div id="queueSize" class="big">0</div></div>
    <div style="height:12px"></div>
    <div class="small" style="color:var(--muted);margin-bottom:8px">Quick stats</div>
    <div class="stat-row"><div class="small">Correct</div><div id="correctCount" class="big">0</div></div>
    <div class="stat-row"><div class="small">Wrong</div><div id="wrongCount" class="big">0</div></div>
    <div style="height:10px"></div>
    <div style="display:flex;gap:8px;margin-top:12px;">
      <button id="muteBtn" class="btn secondary">Sound: Off</button>
      <button id="hintBtn" class="btn">Hint</button>
    </div>
  </aside>
</div>

<footer>Tip: Correct → level up (auto). Wrong → pair added twice to queue (spaced repetition). Final flashcard speed = 1s (Normal).</footer>

<script>
/* ================= DATA: EC2 terms & sub-types ================= */
const TERM_MAP = {
  "On-Demand": [
    "No commitment; billed per second (or hour). Pay for what you use.",
    "Best for unpredictable or short-term workloads."
  ],
  "Savings Plans": [
    "Compute Savings Plan: flexible across EC2, Fargate, Lambda (1/3 year).",
    "EC2 Instance Savings Plan: commits to instance family in a region.",
    "Requires 1- or 3-year commitment with different payment options."
  ],
  "Reserved Instances": [
    "Standard RI: highest discount for a fixed term (1 or 3 years).",
    "Convertible RI: change instance family/type during term.",
    "Zonal RI provides capacity reservation in an AZ."
  ],
  "Spot Instances": [
    "Up to ~90% discount but instances can be interrupted with a 2-min warning.",
    "Best for batch, stateless, fault-tolerant workloads.",
    "Use Spot capacity strategies to reduce interruptions."
  ],
  "Dedicated Hosts": [
    "Physical server dedicated to you; good for BYOL (bring your own license).",
    "Useful for Windows Server or SQL Server licensing control."
  ],
  "Capacity Reservations": [
    "Reserve capacity in an AZ for a time window; keeps capacity available.",
    "No long-term discount by default; ensures capacity when needed."
  ]
};

/* Build allPairs array */
let allPairs = [];
(function buildAllPairs(){
  let id = 0;
  for (const term of Object.keys(TERM_MAP)){
    for (const desc of TERM_MAP[term]){
      allPairs.push({ id: id++, term, desc });
    }
  }
})();

/* ================ GAME STATE ================ */
let queue = [];           // working queue: array of pair objects
let currentPair = null;   // { id, term, desc, sideShown }
let flashcardTimer = null;
let playerStarted = false;
let paused = false;

let level = 1;
let score = 0;
let streak = 0;
let correctCount = 0;
let wrongCount = 0;
let qAnswered = 0;
let totalQuestions = 0;

/* sound (optional, toggled) */
let soundOn = false;
function beep(freq=440, dur=120){
  if (!soundOn) return;
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.connect(g); g.connect(ctx.destination);
    osc.type = 'sine'; osc.frequency.value = freq;
    g.gain.value = 0.05;
    osc.start();
    setTimeout(()=>{ osc.stop(); ctx.close(); }, dur);
  }catch(e){ /* ignore */ }
}

/* ================= Difficulty / Timing helpers ================ */

/* Flashcard time mapping per level (normal final speed = 1s) */
function flashTimeForLevel(lv){
  if (lv <= 1) return 4.0;
  if (lv <= 2) return 3.5;
  if (lv <= 3) return 3.0;
  if (lv <= 5) return 2.5;
  if (lv <= 7) return 2.0;
  if (lv <= 10) return 1.5;
  return 1.0; // final / cap
}

/* Options count by level */
function optionsForLevel(lv){
  if (lv <= 3) return 3;
  if (lv <= 6) return 4;
  if (lv <= 10) return 5;
  return 6;
}

/* ================== Utilities ================== */
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* Replenish queue if it becomes small — ensures endless gameplay */
function ensureQueue(minSize=8){
  if (queue.length >= minSize) return;
  // add shuffled allPairs copies (not references)
  const pool = shuffle(allPairs.slice());
  for (let i=0; i<pool.length && queue.length < minSize*2; i++){
    queue.push(Object.assign({}, pool[i]));
  }
  updateHUD();
}

/* Reset game */
function resetGame(){
  queue = [];
  // seed queue with two full shuffled rounds to give variety
  let pool = shuffle(allPairs.slice());
  queue = queue.concat(pool.map(p => Object.assign({}, p)));
  pool = shuffle(allPairs.slice());
  queue = queue.concat(pool.map(p => Object.assign({}, p)));
  level = 1; score = 0; streak = 0; correctCount = 0; wrongCount = 0; qAnswered = 0;
  playerStarted = false;
  paused = false;
  currentPair = null;
  updateHUD();
  renderIdle();
}

/* Start/Play next flashcard */
function startGame(){
  if (playerStarted && !paused) return;
  if (!playerStarted) {
    resetGame();
  }
  playerStarted = true; paused = false;
  pickNextAndShow();
}

/* Pause */
function pauseGame(){
  paused = !paused;
  if (paused){
    clearTimeout(flashcardTimer);
    document.getElementById('startBtn').textContent = 'Resume';
    document.getElementById('pauseBtn').textContent = 'Paused';
  } else {
    document.getElementById('startBtn').textContent = 'Start';
    document.getElementById('pauseBtn').textContent = 'Pause';
    if (!currentPair) pickNextAndShow();
  }
}

/* Pick next pair and show the flashcard */
function pickNextAndShow(){
  if (paused) return;
  ensureQueue(8);
  if (queue.length === 0){
    // nothing — rebuild queue
    resetGame();
  }

  // pick a random index from queue and splice it out
  const idx = Math.floor(Math.random() * queue.length);
  const p = queue.splice(idx, 1)[0];

  // randomly choose whether to show term or description
  const side = (Math.random() < 0.5) ? 'term' : 'desc';
  currentPair = Object.assign({}, p, { sideShown: side });
  renderFlashcard(currentPair);

  // schedule hide
  const timeSec = flashTimeForLevel(level);
  document.getElementById('flashTimeLabel').textContent = timeSec.toFixed(2) + 's';
  document.getElementById('timeLabel').textContent = timeSec.toFixed(2) + 's';

  clearTimeout(flashcardTimer);
  flashcardTimer = setTimeout(() => {
    hideFlashcardAndShowOptions(currentPair);
  }, Math.round(timeSec * 1000));
}

/* Render flashcard text */
function renderFlashcard(pair){
  const el = document.getElementById('flashcard');
  el.classList.remove('hidden');
  el.textContent = pair.sideShown === 'term' ? pair.term : pair.desc;
  document.getElementById('sideLabel').textContent = pair.sideShown === 'term' ? 'Term' : 'Description';
  document.getElementById('optsLabel').textContent = optionsForLevel(level);
  document.getElementById('optionsLabel').textContent = optionsForLevel(level);
  updateHUD();
  // clear options area
  document.getElementById('options').innerHTML = '';
}

/* Hide flashcard and present options (MCQ) */
function hideFlashcardAndShowOptions(pair){
  if (paused) return;
  const el = document.getElementById('flashcard');
  el.classList.add('hidden');
  el.textContent = '— Remembered —';

  // build correct answer and distractors
  const correct = (pair.sideShown === 'term') ? pair.desc : pair.term;
  const pool = allPairs.map(p => (pair.sideShown === 'term' ? p.desc : p.term)).filter(t => t !== correct);
  const optCount = optionsForLevel(level);
  shuffle(pool);
  const distractors = pool.slice(0, Math.max(0, optCount - 1));
  let choices = shuffle([correct, ...distractors]);

  // If insufficient pool (edge cases), fill with shorter variations or repeat harmlessly
  while (choices.length < optCount) choices.push('— similar —');

  // render buttons
  const container = document.getElementById('options');
  container.innerHTML = '';
  choices.forEach(choice => {
    const btn = document.createElement('button');
    btn.className = 'option-btn';
    btn.textContent = choice;
    btn.onclick = () => handleAnswer(choice, correct, btn);
    container.appendChild(btn);
  });
}

/* Handle answer selected */
function handleAnswer(selected, correct, btnEl){
  if (paused) return;
  qAnswered++;
  document.getElementById('qcount').textContent = qAnswered;
  // disable all options
  const btns = Array.from(document.querySelectorAll('.option-btn'));
  btns.forEach(b => b.disabled = true);

  if (selected === correct){
    // correct
    correctCount++;
    streak++;
    level = Math.max(1, level + 1); // level up by 1
    const gain = 10 * level;
    score += gain;
    beep(880,120);
    btnEl.classList.add('correct');
    // small reward: do not re-add pair (mastered)
    // update HUD
    document.getElementById('resultTemp')?.remove();
    const r = document.createElement('div');
    r.id = 'resultTemp';
    r.innerHTML = `<div style="color:var(--good);margin-top:8px">+${gain} points (level ↑)</div>`;
    document.getElementById('options').appendChild(r);
  } else {
    // wrong
    wrongCount++;
    streak = 0;
    score -= 5;
    score = Math.max(0, score);
    beep(280,200);
    btnEl.classList.add('wrong');
    // spaced repetition: add this pair twice into queue
    queue.push(Object.assign({}, currentPair));
    queue.push(Object.assign({}, currentPair));
    const r = document.createElement('div');
    r.id = 'resultTemp';
    r.innerHTML = `<div style="color:var(--bad);margin-top:8px">−5 points — will repeat this item</div>`;
    document.getElementById('options').appendChild(r);
  }

  updateHUD();

  // after a short pause, move to next
  setTimeout(() => {
    // clear options and proceed
    document.getElementById('options').innerHTML = '';
    // small gentle shuffle of queue occasionally
    if (Math.random() < 0.25) shuffle(queue);
    // pick next
    pickNextAndShow();
  }, 900);
}

/* Hint = show the correct answer for 2s but penalize slightly (-2 points) */
function showHint(){
  if (paused || !currentPair) return;
  score = Math.max(0, score - 2);
  // reveal answer visually
  hideFlashcardAndShowOptions(currentPair);
  // find correct button and visually flash it
  setTimeout(() => {
    const btns = Array.from(document.querySelectorAll('.option-btn'));
    btns.forEach(b => {
      if (b.textContent === ((currentPair.sideShown==='term')?currentPair.desc:currentPair.term)){
        b.classList.add('correct');
      }
    });
  }, 120);
  updateHUD();
}

/* Skip = penalize -2 and go next */
function skipQuestion(){
  if (!currentPair) return;
  score = Math.max(0, score - 2);
  // push current back lightly (once) to queue for later
  queue.push(Object.assign({}, currentPair));
  updateHUD();
  // clear UI and next
  document.getElementById('options').innerHTML = '';
  pickNextAndShow();
}

/* Update HUD and labels */
function updateHUD(){
  document.getElementById('level').textContent = level;
  document.getElementById('score').textContent = Math.max(0, score);
  document.getElementById('streak').textContent = streak;
  document.getElementById('correctCount').textContent = correctCount;
  document.getElementById('wrongCount').textContent = wrongCount;
  document.getElementById('queueSize').textContent = queue.length;
  document.getElementById('optsLabel').textContent = optionsForLevel(level);
  document.getElementById('optionsLabel').textContent = optionsForLevel(level);
  document.getElementById('flashTimeLabel').textContent = flashTimeForLevel(level).toFixed(2) + 's';
}

/* render idle state */
function renderIdle(){
  document.getElementById('flashcard').classList.remove('hidden');
  document.getElementById('flashcard').textContent = 'Press Start to begin';
  document.getElementById('options').innerHTML = '';
}

/* Wire buttons */
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('pauseBtn').addEventListener('click', () => { pauseGame(); document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause'; });
document.getElementById('resetBtn').addEventListener('click', () => { resetGame(); renderIdle(); });
document.getElementById('hintBtn').addEventListener('click', showHint);
document.getElementById('skipBtn').addEventListener('click', skipQuestion);
document.getElementById('muteBtn').addEventListener('click', () => { soundOn = !soundOn; document.getElementById('muteBtn').textContent = soundOn ? 'Sound: On' : 'Sound: Off'; });

/* initialize */
resetGame();
renderIdle();

/* auto start disabled by default; uncomment to auto-start:
startGame();
*/
</script>

</body>
</html>